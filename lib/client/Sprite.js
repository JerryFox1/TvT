// Generated by CoffeeScript 1.4.0
(function() {
  var Sprite,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Sprite = (function(_super) {

    __extends(Sprite, _super);

    function Sprite(args) {
      var _this = this;
      if (args == null) {
        args = {};
      }
      if (args.world != null) {
        this.world = args.world;
      }
      Sprite.__super__.constructor.call(this, args);
      this.worldInfo = {
        position: {
          x: 0,
          y: 0
        },
        rotation: 0,
        velocity: {
          x: 0,
          y: 0
        },
        maxVelocity: 0,
        velocityFactor: 0,
        angularVelocity: 0,
        maxAngularVelocity: 0,
        angularVelocityFactor: 0
      };
      $(window).resize(function() {
        return _this.updated = true;
      });
    }

    Sprite.prototype.update = function(elapsedMS) {
      if (this.worldInfo.angularVelocityFactor !== 0 || this.worldInfo.velocityFactor !== 0) {
        this.updateVelocity();
      }
      if (this.worldInfo.angularVelocityFactor !== 0) {
        this.worldInfo.rotation += this.worldInfo.angularVelocity * (elapsedMS / 1000);
        this.rotation = this.worldInfo.rotation * (180 / Math.PI);
      }
      if (this.worldInfo.velocityFactor !== 0) {
        this.worldInfo.position.x += this.worldInfo.velocity.x * (elapsedMS / 1000);
        this.worldInfo.position.y += this.worldInfo.velocity.y * (elapsedMS / 1000);
        this.position = this.worldInfo.position;
      }
      return Sprite.__super__.update.call(this, elapsedMS);
    };

    Sprite.prototype.draw = function(ctx) {
      if (this.world.camera != null) {
        return Sprite.__super__.draw.call(this, ctx, this.world.camera.transformView);
      } else {
        return Sprite.__super__.draw.call(this, ctx);
      }
    };

    Sprite.prototype.updateVelocity = function() {
      this.worldInfo.velocity.x = Math.cos(this.worldInfo.rotation + (Math.PI / 2)) * this.worldInfo.velocityFactor * this.worldInfo.maxVelocity;
      this.worldInfo.velocity.y = Math.sin(this.worldInfo.rotation + (Math.PI / 2)) * this.worldInfo.velocityFactor * this.worldInfo.maxVelocity;
    };

    return Sprite;

  })(pulse.Sprite);

  module.exports = Sprite;

}).call(this);
